{"model_name_or_path": "agentless", "instance_id": "tailwindlabs__tailwindcss-7665", "model_patch": "diff --git a/src/lib/generateRules.js b/src/lib/generateRules.js\nindex 1ff2800..b7f6bf6 100644\n--- a/src/lib/generateRules.js\n+++ b/src/lib/generateRules.js\n@@ -617,7 +617,7 @@ function generateRules(candidates, context) {\n }\n \n function isArbitraryValue(input) {\n-  return input.startsWith('[') && input.endsWith(']')\n+  return input.startsWith('[') && input.endsWith(']') && input.length > 2\n }\n \n export { resolveMatches, generateRules }\n"}
{"model_name_or_path": "agentless", "instance_id": "tailwindlabs__tailwindcss-4260", "model_patch": ""}
{"model_name_or_path": "agentless", "instance_id": "tailwindlabs__tailwindcss-8608", "model_patch": ""}
{"model_name_or_path": "agentless", "instance_id": "tailwindlabs__tailwindcss-6469", "model_patch": "diff --git a/src/util/escapeClassName.js b/src/util/escapeClassName.js\nindex cb5924a..4ca60d4 100644\n--- a/src/util/escapeClassName.js\n+++ b/src/util/escapeClassName.js\n@@ -1,8 +1,14 @@\n+\n import parser from 'postcss-selector-parser'\n import escapeCommas from './escapeCommas'\n \n export default function escapeClassName(className) {\n   let node = parser.className()\n   node.value = className\n-  return escapeCommas(node?.raws?.value ?? node.value)\n+  let escaped = escapeCommas(node?.raws?.value ?? node.value)\n+  \n+  // Escape square brackets and their contents\n+  escaped = escaped.replace(/\\[([^\\]]+)\\]/g, '\\\\[$1\\\\]')\n+  \n+  return escaped\n }\n"}
{"model_name_or_path": "agentless", "instance_id": "iamkun__dayjs-2532", "model_patch": "diff --git a/src/plugin/timezone/index.js b/src/plugin/timezone/index.js\nindex 832fb4a..29ee4d5 100644\n--- a/src/plugin/timezone/index.js\n+++ b/src/plugin/timezone/index.js\n@@ -42,6 +42,19 @@ export default (o, c, d) => {\n     return dtf.formatToParts(date)\n   }\n \n+  const oldParse = c.prototype.parse\n+  c.prototype.parse = function (cfg) {\n+    if (cfg.utc) {\n+      this.$u = true\n+    }\n+    const parsed = oldParse.call(this, cfg)\n+    if (this.$u) {\n+      this.$offset = 0\n+      this.$x = { $timezone: 'Etc/UTC' }\n+    }\n+    return parsed\n+  }\n+\n   const tzOffset = (timestamp, timezone) => {\n     const formatResult = makeFormatParts(timestamp, timezone)\n     const filled = []\n@@ -147,4 +160,4 @@ export default (o, c, d) => {\n   d.tz.setDefault = function (timezone) {\n     defaultTimezone = timezone\n   }\n-}\n+}\n"}
{"model_name_or_path": "agentless", "instance_id": "iamkun__dayjs-1307", "model_patch": "diff --git a/src/plugin/timezone/index.js b/src/plugin/timezone/index.js\nindex 97f2406..159040d 100644\n--- a/src/plugin/timezone/index.js\n+++ b/src/plugin/timezone/index.js\n@@ -45,14 +45,10 @@ export default (o, c, d) => {\n   }\n \n   const tzOffset = (timestamp, timezone) => {\n-    const formatResult = makeFormatParts(timestamp, timezone)\n-    const filled = []\n-    for (let i = 0; i < formatResult.length; i += 1) {\n-      const { type, value } = formatResult[i]\n-      const pos = typeToPos[type]\n-\n-      if (pos >= 0) {\n-        filled[pos] = parseInt(value, 10)\n+    const date = new Date(timestamp)\n+    const utc = new Date(date.toLocaleString('en-US', { timeZone: 'UTC' }))\n+    const tzDate = new Date(date.toLocaleString('en-US', { timeZone: timezone }))\n+    return (utc.getTime() - tzDate.getTime()) / 60000\n       }\n     }\n     const hour = filled[3]\n@@ -147,4 +143,4 @@ export default (o, c, d) => {\n   d.tz.setDefault = function (timezone) {\n     defaultTimezone = timezone\n   }\n-}\n+}\n"}
{"model_name_or_path": "agentless", "instance_id": "tailwindlabs__tailwindcss-10943", "model_patch": "diff --git a/src/lib/expandApplyAtRules.js b/src/lib/expandApplyAtRules.js\nindex c6d53d8..822b6d6 100644\n--- a/src/lib/expandApplyAtRules.js\n+++ b/src/lib/expandApplyAtRules.js\n@@ -280,6 +280,30 @@ function processApply(root, context, localCache) {\n   // Fill up some caches!\n   let applyClassCache = combineCaches([localCache, buildApplyCache(applyCandidates, context)])\n \n+  // Ensure that all @apply rules are processed\n+  for (let apply of applies) {\n+    let [candidates, important] = extractApplyCandidates(apply.params)\n+    let parent = apply.parent\n+\n+    for (let candidate of candidates) {\n+      if (!applyClassCache.has(candidate)) {\n+        throw apply.error(`The \\`${candidate}\\` class does not exist. If \\`${candidate}\\` is a custom class, make sure it is defined within a \\`@layer\\` directive.`)\n+      }\n+\n+      let rules = applyClassCache.get(candidate)\n+\n+      for (let [, rule] of rules) {\n+        let clonedRule = rule.clone()\n+        clonedRule.walkDecls(decl => {\n+          decl.important = important\n+        })\n+        parent.insertBefore(apply, clonedRule)\n+      }\n+    }\n+\n+    apply.remove()\n+  }\n+\n   /**\n    * When we have an apply like this:\n    *\n"}
{"model_name_or_path": "agentless", "instance_id": "tailwindlabs__tailwindcss-7789", "model_patch": "diff --git a/src/lib/setupContextUtils.js b/src/lib/setupContextUtils.js\nindex ed1cdba..c9b2bea 100644\n--- a/src/lib/setupContextUtils.js\n+++ b/src/lib/setupContextUtils.js\n@@ -102,6 +102,9 @@ function extractCandidates(node, state = { containsNonOnDemandable: false }, dep\n   // Handle normal rules\n   if (node.type === 'rule') {\n     for (let selector of node.selectors) {\n+      // Ignore commented-out selectors\n+      if (selector.trim().startsWith('//')) continue;\n+\n       let classCandidates = getClasses(selector)\n       // At least one of the selectors contains non-\"on-demandable\" candidates.\n       if (classCandidates.length === 0) {\n@@ -880,4 +883,4 @@ export function getContext(\n   contextSourcesMap.get(context).add(sourcePath)\n \n   return [context, true]\n-}\n+}\n"}
{"model_name_or_path": "agentless", "instance_id": "tailwindlabs__tailwindcss-7102", "model_patch": ""}
{"model_name_or_path": "agentless", "instance_id": "tailwindlabs__tailwindcss-7588", "model_patch": "diff --git a/src/lib/setupContextUtils.js b/src/lib/setupContextUtils.js\nindex c4740c4..51ab723 100644\n--- a/src/lib/setupContextUtils.js\n+++ b/src/lib/setupContextUtils.js\n@@ -80,7 +80,7 @@ function parseStyles(styles) {\n \n   return styles.flatMap((style) => {\n     let isNode = !Array.isArray(style) && !isPlainObject(style)\n-    return isNode ? style : parseObjectStyles(style)\n+    return isNode ? style : parseObjectStyles(style, { from: 'preflight' })\n   })\n }\n \n@@ -897,4 +897,4 @@ export function getContext(\n   contextSourcesMap.get(context).add(sourcePath)\n \n   return [context, true]\n-}\n+}\n"}
{"model_name_or_path": "agentless", "instance_id": "tailwindlabs__tailwindcss-11111", "model_patch": "diff --git a/src/util/pseudoElements.js b/src/util/pseudoElements.js\nindex 9f0e54c..2893bde 100644\n--- a/src/util/pseudoElements.js\n+++ b/src/util/pseudoElements.js\n@@ -86,10 +86,20 @@ export function movePseudos(sel) {\n   // Examples:\n   //  - `before:hover:text-center` would result in `.before\\:hover\\:text-center:hover::before`\n   //  - `hover:before:text-center` would result in `.hover\\:before\\:text-center:hover::before`\n+  //  - `marker:text-red-500` would result in `.marker\\:text-red-500::marker`\n   //\n   // The selector `::before:hover` does not work but we\n   // can make it work for you by flipping the order.\n-  sel.nodes.push(...pseudos.map(([, pseudo]) => pseudo))\n+  sel.nodes.push(...pseudos.map(([, pseudo]) => {\n+    // Special handling for marker pseudo-element\n+    if (pseudo.value === '::marker') {\n+      return {\n+        ...pseudo,\n+        value: ':marker'\n+      }\n+    }\n+    return pseudo\n+  }))\n \n   return sel\n }\n@@ -138,7 +148,7 @@ function movablePseudos(sel) {\n  * @returns {boolean}\n  */\n function isPseudoElement(node) {\n-  return node.value.startsWith('::') || elementProperties[node.value] !== undefined\n+  return node.value.startsWith('::') || node.value === ':marker' || elementProperties[node.value] !== undefined\n }\n \n /**\n@@ -167,4 +177,4 @@ function isAttachablePseudoClass(node, pseudo) {\n  */\n function propertiesForPseudo(pseudo) {\n   return elementProperties[pseudo.value] ?? elementProperties.__default__\n-}\n+}\n"}
{"model_name_or_path": "agentless", "instance_id": "tailwindlabs__tailwindcss-10212", "model_patch": "diff --git a/src/lib/generateRules.js b/src/lib/generateRules.js\nindex 636b9ea..2807d0c 100644\n--- a/src/lib/generateRules.js\n+++ b/src/lib/generateRules.js\n@@ -606,52 +606,21 @@ function* resolveMatches(candidate, context, original = candidate) {\n     }\n \n     if (isArbitraryValue(modifier)) {\n+      // Always treat the content as an arbitrary value, regardless of brackets\n+      let arbitraryValue = modifier.slice(1, -1);\n+      \n       if (matches.length > 1) {\n-        // Partition plugins in 2 categories so that we can start searching in the plugins that\n-        // don't have `any` as a type first.\n-        let [withAny, withoutAny] = matches.reduce(\n-          (group, plugin) => {\n-            let hasAnyType = plugin.some(([{ options }]) =>\n-              options.types.some(({ type }) => type === 'any')\n+        // Use the first match that can handle the arbitrary value\n+        matches = matches.filter(match => \n+          match.some(([{ options }]) => \n+            options.types.some(({ type }) => \n+              type === 'any' || arbitraryValue.startsWith(type + ':')\n             )\n+          )\n+        );\n \n-            if (hasAnyType) {\n-              group[0].push(plugin)\n-            } else {\n-              group[1].push(plugin)\n-            }\n-            return group\n-          },\n-          [[], []]\n-        )\n-\n-        function findFallback(matches) {\n-          // If only a single plugin matches, let's take that one\n-          if (matches.length === 1) {\n-            return matches[0]\n-          }\n-\n-          // Otherwise, find the plugin that creates a valid rule given the arbitrary value, and\n-          // also has the correct type which preferOnConflicts the plugin in case of clashes.\n-          return matches.find((rules) => {\n-            let matchingTypes = typesByMatches.get(rules)\n-            return rules.some(([{ options }, rule]) => {\n-              if (!isParsableNode(rule)) {\n-                return false\n-              }\n-\n-              return options.types.some(\n-                ({ type, preferOnConflict }) => matchingTypes.includes(type) && preferOnConflict\n-              )\n-            })\n-          })\n-        }\n-\n-        // Try to find a fallback plugin, because we already know that multiple plugins matched for\n-        // the given arbitrary value.\n-        let fallback = findFallback(withoutAny) ?? findFallback(withAny)\n-        if (fallback) {\n-          matches = [fallback]\n+        if (matches.length > 0) {\n+          matches = [matches[0]];\n         }\n \n         // We couldn't find a fallback plugin which means that there are now multiple plugins that\n@@ -864,4 +833,4 @@ function isArbitraryValue(input) {\n   return input.startsWith('[') && input.endsWith(']')\n }\n \n-export { resolveMatches, generateRules }\n+export { resolveMatches, generateRules }\n"}
{"model_name_or_path": "agentless", "instance_id": "tailwindlabs__tailwindcss-12324", "model_patch": ""}
{"model_name_or_path": "agentless", "instance_id": "webpack__webpack-15454", "model_patch": ""}
{"model_name_or_path": "agentless", "instance_id": "prettier__prettier-12177", "model_patch": ""}
{"model_name_or_path": "agentless", "instance_id": "webpack__webpack-14782", "model_patch": ""}
{"model_name_or_path": "agentless", "instance_id": "statsmodels__statsmodels-7757", "model_patch": "diff --git a/statsmodels/miscmodels/ordinal_model.py b/statsmodels/miscmodels/ordinal_model.py\nindex 91fc8bc..f300869 100644\n--- a/statsmodels/miscmodels/ordinal_model.py\n+++ b/statsmodels/miscmodels/ordinal_model.py\n@@ -212,6 +212,10 @@ class OrderedModel(GenericLikelihoodModel):\n                 endog.name = endog_name\n                 is_pandas = True\n \n+        # Check for NaN values in endog\n+        if np.isnan(endog).any():\n+            raise ValueError(\"missing values in endog are not supported\")\n+\n         return endog, labels, is_pandas\n \n     def _initialize_labels(self, labels, k_levels=None):\n"}
{"model_name_or_path": "agentless", "instance_id": "tqdm__tqdm-535", "model_patch": "diff --git a/tqdm/_tqdm.py b/tqdm/_tqdm.py\nindex 26f9ce8..562b53f 100644\n--- a/tqdm/_tqdm.py\n+++ b/tqdm/_tqdm.py\n@@ -545,6 +545,13 @@ class tqdm(object):\n \n         deprecated_t = [tkwargs.pop('deprecated_t', None)]\n \n+        if 'total' in tkwargs:\n+            import warnings\n+            warnings.warn(\"Setting `total` manually in tqdm.pandas() is not recommended. \"\n+                          \"It will be ignored in progress_apply and progress_applymap.\",\n+                          TqdmWarning)\n+            tkwargs.pop('total')\n+\n         def inner_generator(df_function='apply'):\n             def inner(df, func, *args, **kwargs):\n                 \"\"\"\n"}
